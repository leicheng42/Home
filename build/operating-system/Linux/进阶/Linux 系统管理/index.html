<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-operating-system docs-doc-id-Linux/进阶/Linux 系统管理">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Linux 系统管理 | Lei Cheng&#x27;s HomePage</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://www.leicheng42.com/operating-system/Linux/进阶/Linux 系统管理"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-operating-system-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-operating-system-current"><meta data-rh="true" property="og:title" content="Linux 系统管理 | Lei Cheng&#x27;s HomePage"><meta data-rh="true" name="description" content="Linux 系统管理和配置"><meta data-rh="true" property="og:description" content="Linux 系统管理和配置"><meta data-rh="true" name="keywords" content="Linux,系统管理"><link data-rh="true" rel="icon" href="/img/avatar.jpg"><link data-rh="true" rel="canonical" href="https://www.leicheng42.com/operating-system/Linux/进阶/Linux 系统管理"><link data-rh="true" rel="alternate" href="https://www.leicheng42.com/operating-system/Linux/进阶/Linux 系统管理" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://www.leicheng42.com/operating-system/Linux/进阶/Linux 系统管理" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://YN0RH7UG4B-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Lay`s Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Lay`s Blog Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="Lay`s Blog JSON Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Lei Cheng&#39;s HomePage" href="/opensearch.xml"><link rel="stylesheet" href="/assets/css/styles.a4f24b4d.css">
<link rel="preload" href="/assets/js/runtime~main.5d1b5b77.js" as="script">
<link rel="preload" href="/assets/js/main.45c06b54.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">🏠 Lay 的主页</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/blog">📝 博客</a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd sidebarWithHideableNavbar_wUlq"><a tabindex="-1" class="sidebarLogo_isFc" href="/"><b>🏠 Lay 的主页</b></a><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/operating-system/">Home</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/operating-system/category/文化">Linux</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/operating-system/category/文化">文化</a><button aria-label="打开/收起侧边栏菜单「文化」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/operating-system/category/基础">基础</a><button aria-label="打开/收起侧边栏菜单「基础」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/operating-system/category/进阶">进阶</a><button aria-label="打开/收起侧边栏菜单「进阶」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/operating-system/Linux/进阶/Linux 系统管理">Linux 系统管理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/operating-system/Linux/进阶/Linux 文件系统">Linux 文件系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/operating-system/Linux/进阶/Linux 网络配置">Linux 网络配置</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/operating-system/Linux/进阶/Linux 日志监控">Linux 日志监控</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/operating-system/Linux/进阶/Linux 系统安全与防护">Linux 系统安全与防护</a></li></ul></li></ul></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Linux 系统管理</h1></header><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="引言">引言<a href="#引言" class="hash-link" aria-label="引言的直接链接" title="引言的直接链接">​</a></h2><p>Linux，一种自由和开源的操作系统，因其强大的定制性和稳定性，在全球各地的服务器、桌面、移动设备等领域得到了广泛应用。无论是云计算的基础设施，还是物联网设备的操作系统，Linux 都是核心的选择。然而，为了充分利用 Linux 的潜力，了解其如何启动和运行，以及如何管理运行级别，是必不可少的。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="系统启动">系统启动<a href="#系统启动" class="hash-link" aria-label="系统启动的直接链接" title="系统启动的直接链接">​</a></h2><p><strong>Linux 系统的启动过程是多阶段的，涉及硬件、引导加载器、内核和系统初始化等多个阶段。</strong></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="启动启动流程">启动启动流程<a href="#启动启动流程" class="hash-link" aria-label="启动启动流程的直接链接" title="启动启动流程的直接链接">​</a></h3><ol><li><strong>BIOS 阶段</strong>：BIOS（基本输入输出系统）首先检测并初始化硬件，包括处理器、内存、硬盘等。然后，它查找引导设备（通常是硬盘），并从其引导扇区加载第一个引导程序。此外，BIOS/UEFI 还会根据其配置确定启动设备的顺序，例如先尝试从硬盘启动，如果失败则从 USB 设备或网络启动。</li><li><strong>引导加载器阶段</strong>：这个阶段通常由 GRUB（GRand Unified Bootloader）等引导加载器来完成。引导加载器会展示一个菜单供用户选择要启动的操作系统或内核版本，然后它将选定的内核映像以及初始 RAM 磁盘（initrd）加载到内存中。initrd 包含了启动操作系统所需的一些初级程序和驱动，例如文件系统驱动，使得内核可以访问并挂载根文件系统。</li><li><strong>内核阶段</strong>：加载到内存的内核首先会解压自身，然后启动并初始化系统硬件和驱动。这包括设置和初始化处理器和内存管理系统、唤醒和初始化其他的 CPU 核心、探测并初始化系统中的各种硬件设备、设置中断处理程序和系统调用处理程序、初始化虚拟文件系统（VFS）等。接着，它会使用在 initrd 中的程序和驱动来挂载根文件系统。</li><li><strong>系统初始化阶段</strong>：内核成功挂载根文件系统后，会启动第一个进程 init 或 systemd。这个进程会根据预设的运行级别来启动其他的服务和守护进程，完成系统的启动。在这个阶段，init 系统（例如 systemd）不仅启动系统服务，还负责管理这些服务。例如，如果某个服务因故崩溃，init 系统可以自动重新启动它。此外，init 系统还负责设置环境变量、管理系统日志、维护文件系统挂载点等任务。一般来说，init 进程在启动系统服务之后，不会直接进入等待状态，而是会进入一个事件循环，等待如硬件事件、服务状态改变、用户请求等事件，然后根据事件类型进行相应的处理。</li></ol><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="bios-阶段">BIOS 阶段<a href="#bios-阶段" class="hash-link" aria-label="BIOS 阶段的直接链接" title="BIOS 阶段的直接链接">​</a></h4><p>当电脑开机时，会进行一种叫做电源自检（Power-On Self Test，POST）的过程。这个过程是由电脑的基本输入/输出系统（Basic Input/Output System，BIOS）或统一可扩展固件接口（Unified Extensible Firmware Interface，UEFI）来管理的。<strong>POST 是电脑启动过程中的第一个步骤，是为了确定系统的基本硬件设备是否能够正常运行。</strong></p><p>基本的 POST 过程的步骤：</p><ol><li><p><strong>系统电源打开</strong>：当你按下电源开关后，电源供应器开始为整个系统供电。</p></li><li><p><strong>CPU 复位</strong>：电源打开后，中央处理器（CPU）会被复位到预定义的状态。复位过程包括清空 CPU 的寄存器和缓存，设置程序计数器为预定义的地址（在许多系统中，这通常是固定的 ROM 地址）。</p></li><li><p><strong>BIOS/UEFI 初始化</strong>：CPU 开始执行在预定义地址上的代码，这通常是 BIOS/UEFI 的代码。BIOS/UEFI 在启动时，会进行一些基本的系统初始化，如设置中断描述符表、初始化内存控制器等。</p></li><li><p><strong>硬件检查</strong>：BIOS/UEFI 开始进行 POST，检查系统的基本硬件设备。这通常包括内存、硬盘驱动器、键盘、鼠标等设备。这个过程可能包括设备自我检测（如果设备支持的话），也可能包括读写测试（如对内存的读写测试）。</p></li><li><p><strong>错误检查和报告</strong>：如果在 POST 过程中检测到错误，BIOS/UEFI 会报告这个错误。这可能是通过屏幕上的错误消息，或者通过蜂鸣器的蜂鸣声（通常被称为&quot;beep codes&quot;）。</p></li><li><p><strong>启动引导设备</strong>：如果 POST 成功完成，BIOS/UEFI 会开始从引导设备（如硬盘、USB 设备等）加载操作系统。</p></li></ol><p>在这个阶段，有一些系统可能使用 UEFI（统一的可扩展固件接口）而不是传统的 BIOS。UEFI 是一个规范，定义了软件与操作系统和平台固件之间的软件接口。UEFI 启动过程的细节和 BIOS 有所不同，但基本思路是类似的：它<strong>负责初始化硬件，然后加载并运行启动加载器。</strong></p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="引导加载器阶段">引导加载器阶段<a href="#引导加载器阶段" class="hash-link" aria-label="引导加载器阶段的直接链接" title="引导加载器阶段的直接链接">​</a></h4><p><strong>启动加载程序（Bootloader）是在计算机启动过程中，BIOS 或 UEFI 完成硬件检测后，用于加载操作系统内核的一个小程序。</strong>常见的 Linux 启动加载程序有 GRUB（GNU GRand Unified Bootloader）、LILO（Linux Loader）、SYSLINUX 等。</p><p>启动加载程序的基本步骤：</p><ol><li><p><strong>读取配置文件</strong>：启动加载程序首先会读取其配置文件，了解哪些操作系统可供选择，每个操作系统的内核文件存放在何处，是否有特定的启动参数等信息。在 GRUB 中，这个配置文件通常是 /boot/grub/grub.cfg。</p></li><li><p><strong>展示操作系统选择菜单</strong>：根据配置文件，启动加载程序会在屏幕上展示一个菜单，列出所有可用的操作系统（如果有多个的话），并等待用户选择。用户可以在这个时候选择要启动的操作系统，或者修改启动参数。</p></li><li><p><strong>加载操作系统内核</strong>：用户选择了要启动的操作系统后，启动加载程序会找到相应的内核文件，加载到内存中。这个过程可能涉及到文件系统的操作，因为内核文件通常存放在硬盘的某个文件系统中。所以，启动加载程序需要包含一些简单的文件系统驱动程序。</p></li><li><p><strong>传递控制权</strong>：内核文件被加载到内存后，启动加载程序会将 CPU 的控制权传递给内核，然后操作系统开始运行。</p></li></ol><p>引导加载器不仅可以加载 Linux，也可以加载许多其他类型的操作系统。例如，GRUB 支持加载 Linux、Windows、FreeBSD 等等。<strong>这是通过多启动（multi-boot）规范实现的，它定义了一个标准的方法让引导加载器与操作系统内核交互。</strong></p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="内核阶段">内核阶段<a href="#内核阶段" class="hash-link" aria-label="内核阶段的直接链接" title="内核阶段的直接链接">​</a></h4><p><strong>一旦启动加载程序（例如 GRUB）将操作系统内核加载到内存并将控制权移交给它，Linux内核就开始初始化。</strong>在内核初始化过程中，它实际上是在设定一个基本的运行环境，这样用户空间的程序才能在这个环境中运行。在这个环境中，内核提供了许多基本的服务，例如设备驱动、文件系统、网络服务、进程调度等。所有这些服务在用户空间的程序看来就像是操作系统的一部分，但它们实际上都是由内核提供的。</p><p>以下是内核阶段的一些主要步骤：</p><ol><li><p><strong>初始化 CPU 和内存管理</strong>：首先，内核需要设置和初始化处理器和内存管理系统。它会设置页表来管理虚拟内存，检测和初始化 CPU 和其他硬件设备，以及初始化内核数据结构。</p></li><li><p><strong>启动其他 CPU 核心</strong>：在多核处理器系统中，内核需要唤醒和初始化其他的 CPU 核心。</p></li><li><p><strong>设备和驱动初始化</strong>：内核会开始探测并初始化系统中的各种硬件设备。这包括识别硬件设备，加载和初始化设备驱动，以及设置设备的相关参数。</p></li><li><p><strong>设置中断和系统调用处理</strong>：内核会设置中断处理程序，这是处理硬件中断（例如键盘输入、网络数据包到达等）的机制。同时，内核也会设置系统调用处理程序，这是用户空间程序与内核进行交互的主要方式。</p></li><li><p><strong>初始化虚拟文件系统（VFS）</strong>：Linux 内核会初始化虚拟文件系统（VFS），这是管理所有文件和目录的核心组件。</p></li><li><p><strong>挂载根文件系统</strong>：内核会挂载根文件系统（通常是 &quot;/&quot;）。这通常涉及到读取硬盘上的数据，并可能需要启动额外的驱动程序来识别文件系统（如 ext4、btrfs 等）。</p></li><li><p><strong>启动 init 进程</strong>：最后，内核会启动一个特殊的用户空间程序，称为 init 进程。这个进程的进程 ID（PID）是 1，它负责启动所有其他的用户空间程序和服务。</p></li></ol><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="系统初始化阶段">系统初始化阶段<a href="#系统初始化阶段" class="hash-link" aria-label="系统初始化阶段的直接链接" title="系统初始化阶段的直接链接">​</a></h4><p><strong>在 Linux 内核完成初始化并挂载了根文件系统后，它将启动第一个用户空间程序，这个进程通常被称为 init 进程。init 进程的进程 ID（PID）是1，它是所有其他用户空间进程的父进程。</strong>init 进程在系统中有特殊的地位，它负责启动其他所有的系统服务和用户空间进程。</p><p>常见的 init 系统包括 Systemd、Upstart、SysV init 等，它们各自的启动流程可能会有所不同。以下是使用 Systemd 作为 init 系统的一般流程：</p><ol><li><p><strong>启动</strong>：内核首先启动 Systemd 进程，通常是通过执行 /sbin/init 程序。这个程序通常是指向 Systemd 的一个符号链接。</p></li><li><p><strong>读取和解析配置文件</strong>：Systemd 首先读取和解析其配置文件，了解要启动哪些系统服务。这些配置文件通常位于 /etc/systemd/system 或 /lib/systemd/system 目录中，每个文件描述了一个服务的启动信息，如启动命令、依赖关系等。</p></li><li><p><strong>启动系统服务</strong>：Systemd 开始按照配置文件启动系统服务。Systemd 会处理服务之间的依赖关系，确保服务按照正确的顺序启动。这些服务通常包括网络服务、日志服务、定时任务等。</p></li><li><p><strong>启动用户登录服务</strong>：Systemd 会启动一个特殊的服务，用于处理用户登录。这个服务可以是一个命令行登录程序（如 getty 或 mingetty），也可以是一个图形登录界面（如 GDM 或 LightDM）。</p></li></ol><p>在系统初始化阶段，init 系统会根据预设的运行级别启动一系列的系统服务和守护进程。这些运行级别是一个用来定义系统应该运行哪些服务的机制。例如，在某个运行级别，系统可能只启动最必要的服务，以便快速启动或进行故障排查。而在另一个运行级别，系统可能会启动全部的服务，包括图形界面、网络服务等。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="运行级别的概念">运行级别的概念<a href="#运行级别的概念" class="hash-link" aria-label="运行级别的概念的直接链接" title="运行级别的概念的直接链接">​</a></h3><p>运行级别是 Linux 系统中用于定义系统需要运行哪些服务和进程的方式。每个运行级别都有特定的服务和进程集合，可以根据系统的需求进行切换。Linux 系统中包含以下七个运行级别：</p><ol><li><strong>运行级别 0</strong>：系统停机，通常用于正常关闭系统。</li><li><strong>运行级别 1</strong>：单用户模式，通常用于系统维护。</li><li><strong>运行级别 2</strong>：多用户模式，不包括网络服务。</li><li><strong>运行级别 3</strong>：完全的多用户模式，包括网络服务。这通常是Linux系统默认的运行级别。</li><li><strong>运行级别 4</strong>：通常不使用，用户可以自定义。</li><li><strong>运行级别 5</strong>：图形用户模式，启动X Window图形界面。</li><li><strong>运行级别 6</strong>：系统重启。</li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="管理运行级别">管理运行级别<a href="#管理运行级别" class="hash-link" aria-label="管理运行级别的直接链接" title="管理运行级别的直接链接">​</a></h3><p>Linux 系统提供了一些工具和命令，使用户能够查看和更改当前的运行级别。</p><ul><li>使用<code>runlevel</code>命令可以查看当前的运行级别。该命令会输出两个数字，前一个代表前一个运行级别，后一个代表当前运行级别。</li><li>使用<code>init</code>命令加上运行级别的数字，可以更改当前的运行级别。例如，执行<code>init 3</code>会将系统转换到多用户文本模式。</li><li>另外，用户还可以通过编辑<code>/etc/inittab</code>文件来更改系统的默认运行级别。例如，<code>id:3:initdefault:</code>就设置了系统的默认运行级别为 3。</li></ul><p>通过理解 Linux 系统的启动流程和运行级别，可以更好地理解和管理Linux系统的行为和状态。这些知识对于系统管理员来说尤其重要，因为它们直接影响到系统的性能和稳定性。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="进程管理">进程管理<a href="#进程管理" class="hash-link" aria-label="进程管理的直接链接" title="进程管理的直接链接">​</a></h2><p>在操作系统中，理解并掌握进程及其管理是至关重要的，尤其是在类 Unix 的操作系统如 Linux 中，它们是系统正常运行的基础。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="进程的概念">进程的概念<a href="#进程的概念" class="hash-link" aria-label="进程的概念的直接链接" title="进程的概念的直接链接">​</a></h3><p>进程是一个运行的程序的实例。每个<strong>运行中的程序都会生成至少一个进程</strong>。每个进程都有一个<strong>唯一的进程 ID</strong>，也称为 PID，是由系统自动分配的。同时，每个进程都有其父进程。父进程是创建其他进程的进程。<strong>在 Linux 系统中，init 进程（PID 为 1）是所有进程的祖先进程（神父进程）。</strong></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="进程的状态">进程的状态<a href="#进程的状态" class="hash-link" aria-label="进程的状态的直接链接" title="进程的状态的直接链接">​</a></h3><p>Linux 进程有五种状态：运行（Running），等待（Interruptible Sleep），非中断等待（Uninterruptible Sleep），停止（Stopped），僵尸（Zombie）。</p><ul><li><strong>运行状态（Running）</strong>: 进程正在 CPU 上运行或者在运行队列中等待运行。运行状态的进程可能正在使用 CPU ，也可能正在等待 CPU 时间片。</li><li><strong>等待状态（Interruptible Sleep）</strong>: 进程正在等待某个条件（如用户输入或者磁盘 I/O）完成。当满足其等待的条件，它就会转移到运行状态。</li><li><strong>非中断等待状态（Uninterruptible Sleep）</strong>: 与等待状态类似，进程在等待某个条件完成。但这种状态的进程不能被其他进程或者事件唤醒和打断，只有等待的条件被满足，它才会被唤醒。</li><li><strong>停止状态（Stopped）</strong>: 进程被暂停执行，可以由一个信号（signal）触发进入该状态。即使有可用的 CPU 时间，被停止的进程也不会执行。</li><li><strong>僵尸状态（Zombie）</strong>: 这是进程结束（或被其他进程杀死）后的一种状态。尽管进程的主体已经终止，但它在进程表中的条目仍然存在，直到父进程读取了子进程的退出状态信息后，才会消失。</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="进程的优先级">进程的优先级<a href="#进程的优先级" class="hash-link" aria-label="进程的优先级的直接链接" title="进程的优先级的直接链接">​</a></h3><p>在 Linux 系统中，处理器必须在多个并发运行的进程之间分享其时间。<strong>为了公平和有效地管理这些进程，Linux 使用一种称为优先级的机制来确定哪个进程应该优先获取 CPU 时间。</strong>优先级是一种衡量进程重要性和优先级的方法，优先级较高的进程将获得更多的 CPU 时间。</p><p>Linux 系统使用所谓的 Nice 值来表示进程的优先级。Nice 值的范围从 -20（最高优先级）到 19（最低优先级）。默认的 Nice 值是 0。Nice 值越低，进程的优先级就越高，也就是说，它会获得更多的 CPU 时间。反之，Nice 值越高，进程的优先级就越低，获得的 CPU 时间也就越少。</p><p>在 Linux 系统中，你可以使用 <code>nice</code> 和 <code>renice</code> 命令来设置和修改进程的优先级。以下是它们的使用方法：</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># PID 是想要修改的进程的进程 ID，可以使用 ps 或 top 命令来查看进程的 PID</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 使用 nice 命令启动一个新进程，设置其 Nice 值为 10</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">nice</span><span class="token plain"> -n </span><span class="token number" style="color:#36acaa">10</span><span class="token plain"> </span><span class="token builtin class-name">command</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 使用 nice 命令启动一个新进程，设置其 Nice 值为 -5</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">nice</span><span class="token plain"> -n -5 </span><span class="token builtin class-name">command</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 将 PID 为 1234 的进程的 Nice 值设为 10</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">renice</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">10</span><span class="token plain"> -p </span><span class="token number" style="color:#36acaa">1234</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 将 PID 为 5678 的进程的 Nice 值设为 -5</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">renice</span><span class="token plain"> -5 -p </span><span class="token number" style="color:#36acaa">5678</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="进程管理命令">进程管理命令<a href="#进程管理命令" class="hash-link" aria-label="进程管理命令的直接链接" title="进程管理命令的直接链接">​</a></h3><p>Linux 系统中的进程管理命令非常多，包括但不限于<code>ps</code>、<code>top</code>、<code>htop</code>、<code>pgrep</code>、<code>pkill</code>、<code>kill</code>、<code>killall</code>等。这些命令用途广泛，可以帮助我们查看、控制和管理系统中的进程。</p><p>例如，<code>ps</code> 命令是用来查看系统中当前进程状态的命令，其 <code>-ef</code> 选项可以显示所有进程的详细信息，包括进程 ID、所属用户、CPU 占用率、进程启动时间等。</p><p><code>top</code> 命令则可以动态查看系统运行状态，它提供了一个实时更新的系统状态界面，其中包括 CPU 使用情况，内存使用情况，以及进程信息等。</p><p>如果你需要更图形化的界面，<code>htop</code> 是一个更好的选择，它是 <code>top</code> 命令的优化版，提供了一个全彩的，图形化的，交互式的系统监视界面。</p><p><code>pgrep</code> 和 <code>pkill</code> 是一对强大的工具，它们可以根据进程名查找或杀死进程，而无需知道进程ID。特别是在你需要批量操作同名进程时，这两个命令非常有用。</p><p>当然，如果你知道要操作的进程 ID，<code>kill</code> 命令就是你的最佳选择。<code>kill</code>命令可以发送不同的信号给指定的进程，最常用的是 SIGTERM (15) 和 SIGKILL (9)。其中，<code>kill -9 pid</code> 命令可以强制终止指定的进程。</p><p>另外，<code>killall</code>命令也是一个根据进程名杀死进程的命令，与<code>pkill</code>命令功能类似。</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># 查看系统中所有的进程</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">ps</span><span class="token plain"> -ef</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 动态查看系统运行状态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">top</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 使用图形化界面查看系统运行状态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">htop</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 查找名为 bash 的进程 </span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pgrep </span><span class="token function" style="color:#d73a49">bash</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 杀死名为 bash 的进程</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">pkill</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">bash</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 发送 SIGTERM 信号（正常终止）给进程 ID 为 123 的进程</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">kill</span><span class="token plain"> -15 </span><span class="token number" style="color:#36acaa">123</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 发送 SIGKILL 信号（强制终止）给进程 ID 为 123 的进程</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">kill</span><span class="token plain"> -9 </span><span class="token number" style="color:#36acaa">123</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 杀死名为 bash 的所有进程</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">killall</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">bash</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="服务管理">服务管理<a href="#服务管理" class="hash-link" aria-label="服务管理的直接链接" title="服务管理的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="服务的概念">服务的概念<a href="#服务的概念" class="hash-link" aria-label="服务的概念的直接链接" title="服务的概念的直接链接">​</a></h3><p>在 Linux 环境中，服务（也被称为守护进程）是一个关键概念，指的是一种在后台运行的程序或一组程序，这些程序在用户的视觉范围之外，不断地提供某些特定的功能或服务。例如，web 服务器（如Apache），数据库服务器（如MySQL），邮件服务器，SSH，FTP 等都属于典型的服务。这些服务是操作系统正常运行的重要组成部分，负责处理各种系统任务和应用请求。</p><p>服务管理则是操作系统中的一项重要任务，其主要目标是保证服务能够稳定、高效地运行，同时，也能够便捷地进行服务的配置和维护。为了达到这个目标，人们设计了许多不同的服务管理系统，例如 SysV init，Upstart，以及现在广泛使用的 Systemd。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="服务管理-1">服务管理<a href="#服务管理-1" class="hash-link" aria-label="服务管理的直接链接" title="服务管理的直接链接">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="systemd">Systemd<a href="#systemd" class="hash-link" aria-label="Systemd的直接链接" title="Systemd的直接链接">​</a></h4><p><a href="https://systemd.io/" target="_blank" rel="noopener noreferrer">systemd</a> 是当前大多数 Linux 发行版中默认的初始化系统和服务管理器，由 Lennart Poettering 和 Kay Sievers 在 Freedesktop.org 项目中创建。它的主要任务是负责系统的引导流程，以及在系统运行期间管理和维护各种服务。</p><p>与传统的 SysV init 和 Upstart 等系统相比，systemd 提供了许多高级特性。其中一个主要特点就是并行化处理，能同时启动多个服务，大大提高了系统启动的速度。此外，systemd 还支持按需启动服务，即只有在服务被需要时才启动。这些特性加上实时系统状态查看，服务依赖管理，系统资源控制等，使得 systemd 能为用户提供现代化的、高效的、全面的解决方案。</p><p>systemd 还提供了一种新的系统配置方法，即使用 systemd 单元（unit）文件。这些单元文件用于定义服务、设备、挂载点、套接字等对象的属性和行为。单元文件是纯文本文件，易于编辑，支持灵活的配置选项。</p><p>除了基本的初始化服务，systemd 还提供了进程监控、日志管理、设备管理、网络配置、用户会话管理等多项功能。特别是通过日志管理工具 journald，实现了全面的日志管理功能。journald可以收集各种类型的日志信息，包括内核日志、系统服务日志、用户程序日志等，然后将它们统一存储在一个中央日志库中，便于用户查阅和管理。</p><p>尽管 systemd 具有诸多优点，但由于其庞大和复杂，也引来了不少批评。一些人认为 systemd 违反了 Unix 哲学——&quot;做一件事，并把它做好&quot;，它的功能太过全面，违反了模块化设计的原则。然而，也有很多人认为，对于现代Linux系统来说 systemd 是必不可少的。</p><p>以下是一些 systemd 中常用的 <code>systemctl</code> 命令示例：</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># 启动一个服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">systemctl start </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 停止一个服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">systemctl stop </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 重启一个服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">systemctl restart </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 查看一个服务的状态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">systemctl status </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 设置一个服务在系统启动时自动启动</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">systemctl </span><span class="token builtin class-name">enable</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 禁止一个服务在系统启动时自动启动</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">systemctl disable </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>常用的选项：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>--user</code></td><td>对用户级别的服务进行操作，而不是系统级别的服务</td></tr><tr><td><code>--global</code></td><td>对所有用户的用户级别的服务进行操作</td></tr><tr><td><code>--system</code></td><td>对系统级别的服务进行操作，这是默认的操作级别</td></tr><tr><td><code>--all</code></td><td>显示所有的服务，包括未启动的和不活跃的服务</td></tr><tr><td><code>--failed</code></td><td>显示启动失败的服务</td></tr><tr><td><code>-H [user@]hostname</code></td><td>对远程主机上的服务进行操作</td></tr><tr><td><code>--no-pager</code></td><td>不使用分页显示输出结果</td></tr></tbody></table><p>总的来说，<code>systemd</code>是一种强大的初始化系统和服务管理器，它改变了Linux系统的启动方式和服务管理方式，带来了许多新的可能性和便利性。如果你正在使用的是一个现代的Linux发行版，那么你很可能已经在使用<code>systemd</code>了。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="upstart">Upstart<a href="#upstart" class="hash-link" aria-label="Upstart的直接链接" title="Upstart的直接链接">​</a></h4><p>Upstart 是一种为 Linux 系统设计的事件驱动的初始化系统和服务管理器，由 Canonical 公司的 Scott James Remnant 开发，最初用于 Ubuntu 发行版。它的设计初衷是用于取代传统的 SysV init 系统，并且解决其在处理现代化计算环境中的并发性和动态性时的局限性。</p><p>Upstart 的主要特点是事件驱动（Event-Driven），它可以根据系统事件（比如硬件添加或者删除，服务状态变化等）来动态地启动或停止服务。这种设计使得 Upstart 能够灵活地适应不同的系统状态，并确保相关的服务在适当的时机和顺序下启动。</p><p>此外，Upstart 还支持并行启动服务，这大大提高了系统启动的速度。它还具有服务状态跟踪功能，可以在服务异常退出时自动重启服务，从而提高系统的可靠性。</p><p>Upstart 使用的服务配置文件称为 Job 文件，这些文件定义了一个服务的启动条件、停止条件、脚本等信息。Job 文件是纯文本文件，位于 <code>/etc/init</code> 目录下，易于编辑和管理。</p><p>以下是一些 Upstart 中常用的 <code>initctl</code> 命令示例：</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># 启动一个服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">initctl start </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">job_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 停止一个服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">initctl stop </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">job_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 重启一个服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">initctl restart </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">job_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 查看一个服务的状态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">initctl status </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">job_name</span><span class="token punctuation" style="color:#393A34">]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>常用的选项：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>list</code></td><td>列出所有已知的任务和服务</td></tr><tr><td><code>show-config</code></td><td>显示指定任务或服务的所有配置信息</td></tr><tr><td><code>emit</code></td><td>发出一个事件，可以触发相关的任务和服务</td></tr><tr><td><code>reload-configuration</code></td><td>重新加载所有的任务和服务的配置文件</td></tr></tbody></table><p>尽管 Upstart 在其出现时提供了一种新颖和强大的初始化和服务管理方式，但由于其开发和维护的复杂性，以及后来 systemd 的出现，Upstart 在许多 Linux 发行版中被 systemd 替代。然而，了解 Upstart 仍然是有益的，因为有些旧的系统或特定的场景可能仍然在使用它。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="sysv-init">SysV init<a href="#sysv-init" class="hash-link" aria-label="SysV init的直接链接" title="SysV init的直接链接">​</a></h4><p>SysV init 是 Unix System V 中的初始化系统，长期以来在各种 Unix-like 系统中使用，包括早期的 Linux 发行版。它主要负责在系统启动时启动各种服务，以及在系统运行期间管理和维护各种服务。</p><p>SysV init 的主要特点是顺序启动服务。它依赖于在 <code>/etc/inittab</code> 文件中定义的运行级别（runlevels），并在每个运行级别中按照预定义的顺序启动或停止服务。这种设计简单可靠，但在处理现代化计算环境中的并发性和动态性时，表现出一定的局限性。</p><p>在 SysV init 系统中，服务的启动脚本通常位于 <code>/etc/init.d/</code> 目录下，而各个运行级别的服务链接则位于 <code>/etc/rc.d/</code> 或 <code>/etc/rc[runlevel].d/</code> 目录下。这种设计使得服务配置分散在多个文件和目录中，管理相对较复杂。</p><p>以下是一些 SysV init 中常用的命令示例：</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># 启动一个服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/etc/init.d/</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 停止一个服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/etc/init.d/</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> stop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 重启一个服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/etc/init.d/</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> restart</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 查看一个服务的状态</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/etc/init.d/</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">service_name</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> status</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 切换运行级别</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">init </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">runlevel</span><span class="token punctuation" style="color:#393A34">]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>常用的运行级别：</p><table><thead><tr><th>运行级别</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>关机</td></tr><tr><td>1</td><td>单用户模式</td></tr><tr><td>2</td><td>多用户模式（没有网络服务）</td></tr><tr><td>3</td><td>多用户模式（有网络服务）</td></tr><tr><td>4</td><td>未定义，可以由用户自定义</td></tr><tr><td>5</td><td>多用户模式（有网络服务和图形用户界面）</td></tr><tr><td>6</td><td>重启</td></tr></tbody></table><p>尽管 <code>SysV init</code> 系统在设计上有一些局限性，但其简单和可靠的特点使得它在许多年里得到了广泛的使用。然而，随着现代 Linux 系统的发展，更多的发行版开始选择如 <code>Upstart</code> 或 <code>systemd</code> 这样的现代化的初始化系统和服务管理器。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="未来发展">未来发展<a href="#未来发展" class="hash-link" aria-label="未来发展的直接链接" title="未来发展的直接链接">​</a></h3><p>随着云计算、容器技术、微服务等新技术的发展，服务管理面临着新的挑战和机遇。在这样的环境下，服务管理不仅要考虑如何管理单个系统上的服务，还需要考虑如何在分布式环境中协调和管理多个服务。这可能需要新的管理策略和工具，或者是现有工具的深度集成和优化。</p><p>例如，随着 Kubernetes 这样的容器编排工具的普及，服务的生命周期管理和调度已经可以通过这些工具来完成。在这种情况下，传统的服务管理器可能需要与 Kubernetes 等工具进行深度整合，以便更好地在微服务环境中管理服务。</p><p>另一方面，新的服务管理工具和框架也正在不断出现，比如用 Go 语言编写的 <a href="http://supervisord.org/" target="_blank" rel="noopener noreferrer">supervisord</a>，或者是由 Uber 开发的 <a href="https://eng.uber.com/peloton/" target="_blank" rel="noopener noreferrer">Peloton</a>。这些工具都试图在特定环境下提供更好的服务管理能力。</p><p>总的来说，服务管理是一个重要且不断发展的领域。随着新技术的发展，我们期待看到更多的创新和进步，以帮助我们更好地管理和维护系统服务。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="设备驱动管理">设备驱动管理<a href="#设备驱动管理" class="hash-link" aria-label="设备驱动管理的直接链接" title="设备驱动管理的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="设备驱动概述">设备驱动概述<a href="#设备驱动概述" class="hash-link" aria-label="设备驱动概述的直接链接" title="设备驱动概述的直接链接">​</a></h3><p>Linux 设备驱动是操作系统中一个重要的组成部分，负责管理并控制计算机硬件。设备驱动通过提供统一的接口，使得上层的应用软件无需了解底层硬件的细节，就能够利用硬件设备的功能。无论是显卡，网卡，硬盘，USB 设备等，都需要相关的设备驱动来进行管理。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="设备驱动的类型">设备驱动的类型<a href="#设备驱动的类型" class="hash-link" aria-label="设备驱动的类型的直接链接" title="设备驱动的类型的直接链接">​</a></h3><p>在 Linux 中，设备驱动分为静态驱动和动态驱动（也称为模块）两种。静态驱动是在内核编译时直接集成在内核镜像中的，这种驱动的主要优点是启动时就已经可用，但是不能在运行时卸载。动态驱动（模块）则是可以在系统运行时按需加载和卸载的，它提供了更大的灵活性，可以根据需要添加或删除设备驱动，而无需重新编译内核。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="设备驱动的加载与卸载">设备驱动的加载与卸载<a href="#设备驱动的加载与卸载" class="hash-link" aria-label="设备驱动的加载与卸载的直接链接" title="设备驱动的加载与卸载的直接链接">​</a></h3><p>设备驱动的加载和卸载主要通过 modprobe 命令进行。modprobe 是一种在 Linux 中管理模块的命令行工具。例如，通过输入 modprobe driver_name，就可以加载对应的设备驱动；而通过 modprobe -r driver_name 则可以卸载对应的设备驱动。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="设备驱动的配置">设备驱动的配置<a href="#设备驱动的配置" class="hash-link" aria-label="设备驱动的配置的直接链接" title="设备驱动的配置的直接链接">​</a></h3><p>设备驱动的配置通常在加载驱动时通过参数传递，或者在 /etc/modprobe.d 目录下的配置文件中设置。例如，你可以在加载网卡驱动时，通过参数来设置网络速度，全双工或半双工模式等。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="设备驱动的问题诊断与解决">设备驱动的问题诊断与解决<a href="#设备驱动的问题诊断与解决" class="hash-link" aria-label="设备驱动的问题诊断与解决的直接链接" title="设备驱动的问题诊断与解决的直接链接">​</a></h3><p>如果设备驱动出现问题，你可以通过以下几种方式进行诊断和解决：</p><ol><li>使用 <code>dmesg</code> 命令查看内核消息：<code>dmesg</code> 命令可以显示内核的环形缓冲区中的消息，这些消息通常包含了设备驱动的加载、工作状态等信息。通过分析这些消息，可以找到问题的原因。</li><li>查看系统日志：系统日志通常位于 <code>/var/log</code> 目录下，例如 <code>syslog</code>，<code>kern.log</code> 等。这些日志文件通常会包含设备驱动的错误信息，可以帮助你诊断问题。</li><li>使用 <code>lsmod</code> 命令查看已加载的模块：<code>lsmod</code> 命令可以显示当前已经加载的所有设备驱动（模块）。如果你不确定一个驱动是否已经正确加载，可以使用 <code>lsmod | grep driver_name</code> 命令来检查。</li></ol><p>在 Linux 中，设备驱动的管理是一个重要但复杂的任务，它需要你对 Linux 系统有一定的了解，同时也需要具备一定的问题诊断和解决能力。</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="内存管理">内存管理<a href="#内存管理" class="hash-link" aria-label="内存管理的直接链接" title="内存管理的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="内存的组成">内存的组成<a href="#内存的组成" class="hash-link" aria-label="内存的组成的直接链接" title="内存的组成的直接链接">​</a></h3><p>首先，我们要了解 Linux 系统中内存的主要组成部分，它们分别是物理内存、缓冲区、缓存和交换空间。</p><ol><li>物理内存：这是计算机实际拥有的 RAM，也是处理器可以直接访问的存储空间。Linux 内核会将物理内存分割成多个不同的区块，用于存储不同类型的数据。</li><li>缓冲区（Buffer）：缓冲区是一个临时的数据存储区，主要用于存储正在读写的数据，如文件 I/O。缓冲区可以避免系统直接访问硬盘，从而增加了系统的性能。</li><li>缓存（Cache）：缓存是存储经常使用或者最近使用的数据副本的内存区域。数据缓存的目的是提高数据读取速度，减少对硬盘的读写操作。这同样也是为了提高系统的性能。</li><li>交换空间（Swap Space）：交换空间是硬盘上的一个区域，被用作当物理内存不足时的临时存储。交换空间可以被看作是物理内存的扩展，但因为硬盘的读写速度远慢于 RAM，所以使用交换空间会大大降低系统性能。</li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="查看和管理内存使用">查看和管理内存使用<a href="#查看和管理内存使用" class="hash-link" aria-label="查看和管理内存使用的直接链接" title="查看和管理内存使用的直接链接">​</a></h3><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="查看内存使用情况">查看内存使用情况<a href="#查看内存使用情况" class="hash-link" aria-label="查看内存使用情况的直接链接" title="查看内存使用情况的直接链接">​</a></h4><p>在 Linux 中，有许多命令可以帮助我们查看系统的内存使用情况，其中包括 <code>free</code>，<code>top</code> 和 <code>htop</code> 等命令。</p><p><code>free</code> 命令可以显示系统的物理内存、交换空间和缓存的使用情况。例如，执行 <code>free -h</code> 命令，系统就会以人类可读的格式（如 KB，MB，GB）显示内存使用情况。</p><p><code>top</code> 和 <code>htop</code> 命令可以实时显示系统的运行状态，包括内存使用情况，以及每个进程的 CPU 使用率，内存使用率等信息。这些信息可以帮助我们找出那些占用内存过多的进程，以便进行进一步的优化。</p><p>管理交换空间</p><p>在 Linux 中，我们可以使用 <code>swapon</code> 和 <code>swapoff</code> 这两个命令来管理交换空间。<code>swapon</code> 命令可以启用交换空间，例如执行 <code>swapon /dev/sda1</code> 命令就可以启用 <code>/dev/sda1</code> 分区作为交换空间。而 <code>swapoff</code> 命令则可以关闭交换空间，例如执行 <code>swapoff /dev/sda1</code> 命令就可以关闭 <code>/dev/sda1</code> 分区的交换空间。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="清理缓存">清理缓存<a href="#清理缓存" class="hash-link" aria-label="清理缓存的直接链接" title="清理缓存的直接链接">​</a></h4><p>在 Linux 系统中，我们还可以使用一些命令来清理缓存，以便释放内存。例如，执行 <code>sync; echo 3 &gt; /proc/sys/vm/drop_caches</code> 命令就会将所有待写入磁盘的数据写入磁盘，然后清理缓存。然而，清理缓存可能会暂时影响系统性能，因为系统需要重新从磁盘读取数据来填充缓存。因此，我们应在必要时才清理缓存，例如在系统内存非常紧张时。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="内存优化">内存优化<a href="#内存优化" class="hash-link" aria-label="内存优化的直接链接" title="内存优化的直接链接">​</a></h3><p>在 Linux 系统中，内存优化可能包括以下几个方面：调整内核参数，管理服务，以及设置合适的交换空间。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="调整内核参数">调整内核参数<a href="#调整内核参数" class="hash-link" aria-label="调整内核参数的直接链接" title="调整内核参数的直接链接">​</a></h4><p>内核参数是 Linux 内核的配置选项，它们影响内核的行为和性能。例如，我们可以调整页面缓存的大小，影响系统对内存的使用。在 <code>/proc/sys/vm</code> 目录下，有许多可以调整的内核参数，例如 <code>swappiness</code>（影响系统使用交换空间的频率），<code>dirty_ratio</code>（影响系统写入磁盘的频率）等。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="管理服务">管理服务<a href="#管理服务" class="hash-link" aria-label="管理服务的直接链接" title="管理服务的直接链接">​</a></h4><p>在 Linux 系统中，许多服务会在后台运行，占用系统资源。关闭不必要的服务可以减少内存使用，提高系统性能。我们可以使用 <code>systemctl</code> 命令来查看和管理服务，例如 <code>systemctl stop apache2</code> 命令就可以停止 Apache 服务。</p><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="设置合适的交换空间">设置合适的交换空间<a href="#设置合适的交换空间" class="hash-link" aria-label="设置合适的交换空间的直接链接" title="设置合适的交换空间的直接链接">​</a></h4><p>交换空间的大小和位置都会影响系统性能。一般来说，我们建议设置的交换空间大小为物理内存的 1.5 至 2 倍。而交换空间的位置，我们推荐设置在 SSD 上，因为 SSD 的读写速度快于传统的机械硬盘。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-tags-row row margin-bottom--sm"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/operating-system/tags/linux">Linux</a></li></ul></div></div><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://git.7wate.org/zhouzhongping/wiki/src/branch/master/wiki/operating-system/Linux/进阶/Linux 系统管理.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">最后<!-- -->由 <b>7Wate</b> <!-- -->于 <b><time datetime="2023-07-03T08:23:16.000Z">2023年7月3日</time></b> <!-- -->更新</span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/operating-system/category/进阶"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">进阶</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/operating-system/Linux/进阶/Linux 文件系统"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Linux 文件系统</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#引言" class="table-of-contents__link toc-highlight">引言</a></li><li><a href="#系统启动" class="table-of-contents__link toc-highlight">系统启动</a><ul><li><a href="#启动启动流程" class="table-of-contents__link toc-highlight">启动启动流程</a></li><li><a href="#运行级别的概念" class="table-of-contents__link toc-highlight">运行级别的概念</a></li><li><a href="#管理运行级别" class="table-of-contents__link toc-highlight">管理运行级别</a></li></ul></li><li><a href="#进程管理" class="table-of-contents__link toc-highlight">进程管理</a><ul><li><a href="#进程的概念" class="table-of-contents__link toc-highlight">进程的概念</a></li><li><a href="#进程的状态" class="table-of-contents__link toc-highlight">进程的状态</a></li><li><a href="#进程的优先级" class="table-of-contents__link toc-highlight">进程的优先级</a></li><li><a href="#进程管理命令" class="table-of-contents__link toc-highlight">进程管理命令</a></li></ul></li><li><a href="#服务管理" class="table-of-contents__link toc-highlight">服务管理</a><ul><li><a href="#服务的概念" class="table-of-contents__link toc-highlight">服务的概念</a></li><li><a href="#服务管理-1" class="table-of-contents__link toc-highlight">服务管理</a></li><li><a href="#未来发展" class="table-of-contents__link toc-highlight">未来发展</a></li></ul></li><li><a href="#设备驱动管理" class="table-of-contents__link toc-highlight">设备驱动管理</a><ul><li><a href="#设备驱动概述" class="table-of-contents__link toc-highlight">设备驱动概述</a></li><li><a href="#设备驱动的类型" class="table-of-contents__link toc-highlight">设备驱动的类型</a></li><li><a href="#设备驱动的加载与卸载" class="table-of-contents__link toc-highlight">设备驱动的加载与卸载</a></li><li><a href="#设备驱动的配置" class="table-of-contents__link toc-highlight">设备驱动的配置</a></li><li><a href="#设备驱动的问题诊断与解决" class="table-of-contents__link toc-highlight">设备驱动的问题诊断与解决</a></li></ul></li><li><a href="#内存管理" class="table-of-contents__link toc-highlight">内存管理</a><ul><li><a href="#内存的组成" class="table-of-contents__link toc-highlight">内存的组成</a></li><li><a href="#查看和管理内存使用" class="table-of-contents__link toc-highlight">查看和管理内存使用</a></li><li><a href="#内存优化" class="table-of-contents__link toc-highlight">内存优化</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Lei Cheng, Inc. Built with <a href="https://www.docusaurus.cn/" target="_blank" rel="noopener noreferrer">Docusaurus</a>.<br>Powered by <a href="https://vercel.com/" target="_blank" rel="noopener noreferrer">Vercel</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.5d1b5b77.js"></script>
<script src="/assets/js/main.45c06b54.js"></script>
</body>
</html>